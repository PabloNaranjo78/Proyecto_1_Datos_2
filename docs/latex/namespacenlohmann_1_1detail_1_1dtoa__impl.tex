\hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl}{}\doxysection{nlohmann\+::detail\+::dtoa\+\_\+impl Namespace Reference}
\label{namespacenlohmann_1_1detail_1_1dtoa__impl}\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}


implements the Grisu2 algorithm for binary to decimal floating-\/point conversion.  


\doxysubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1boundaries}{boundaries}}
\item 
struct \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1cached__power}{cached\+\_\+power}}
\item 
struct \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Target , typename Source $>$ }\\Target \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a1c5d30eb51e5e994a3f48bde104d2ce8}{reinterpret\+\_\+bits}} (const Source source)
\item 
{\footnotesize template$<$typename Float\+Type $>$ }\\\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1boundaries}{boundaries}} \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded}{compute\+\_\+boundaries}} (Float\+Type value)
\item 
\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1cached__power}{cached\+\_\+power}} \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_adbf329a18c5cf854a3477327afd2200b}{get\+\_\+cached\+\_\+power\+\_\+for\+\_\+binary\+\_\+exponent}} (int e)
\item 
int \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a36ded358763b5dbcea9867660fbe4e28}{find\+\_\+largest\+\_\+pow10}} (const std\+::uint32\+\_\+t n, std\+::uint32\+\_\+t \&pow10)
\item 
void \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a5bc841e0bee12fd6489d49cf7bd07bb4}{grisu2\+\_\+round}} (char $\ast$buf, int len, std\+::uint64\+\_\+t dist, std\+::uint64\+\_\+t delta, std\+::uint64\+\_\+t rest, std\+::uint64\+\_\+t ten\+\_\+k)
\item 
void \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a9b899c72b0e1e3dd46d75c2b4e6bcdfb}{grisu2\+\_\+digit\+\_\+gen}} (char $\ast$buffer, int \&length, int \&decimal\+\_\+exponent, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\+\_\+minus, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} w, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\+\_\+plus)
\item 
void \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a05b681dcb8569b9784c6dccfadb01633}{grisu2}} (char $\ast$buf, int \&len, int \&decimal\+\_\+exponent, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\+\_\+minus, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} v, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\+\_\+plus)
\item 
{\footnotesize template$<$typename Float\+Type $>$ }\\void \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_aab7a9670a4f4704a5d0347ad7588576b}{grisu2}} (char $\ast$buf, int \&len, int \&decimal\+\_\+exponent, Float\+Type value)
\item 
\mbox{\hyperlink{json_8hpp_a5f2aaec3b681d0a72f7d6e90b70cdcd1}{JSON\+\_\+\+HEDLEY\+\_\+\+RETURNS\+\_\+\+NON\+\_\+\+NULL}} char $\ast$ \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_ad90f19ed10d8133b727df4b9bc5ddf5c}{append\+\_\+exponent}} (char $\ast$buf, int e)
\begin{DoxyCompactList}\small\item\em appends a decimal representation of e to buf \end{DoxyCompactList}\item 
\mbox{\hyperlink{json_8hpp_a5f2aaec3b681d0a72f7d6e90b70cdcd1}{JSON\+\_\+\+HEDLEY\+\_\+\+RETURNS\+\_\+\+NON\+\_\+\+NULL}} char $\ast$ \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_ab441f2761e33839ca48bc2225e14a2a9}{format\+\_\+buffer}} (char $\ast$buf, int len, int decimal\+\_\+exponent, int min\+\_\+exp, int max\+\_\+exp)
\begin{DoxyCompactList}\small\item\em prettify v = buf $\ast$ 10$^\wedge$decimal\+\_\+exponent \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
constexpr int \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_ac1ea1316de0b4a219f707c76b1db1966}{k\+Alpha}} = -\/60
\item 
constexpr int \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a4a750fcc38da1ce68b7e25ab3a230e20}{k\+Gamma}} = -\/32
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
implements the Grisu2 algorithm for binary to decimal floating-\/point conversion. 

This implementation is a slightly modified version of the reference implementation which may be obtained from \href{http://florian.loitsch.com/publications}{\texttt{ http\+://florian.\+loitsch.\+com/publications}} (bench.\+tar.\+gz).

The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.

For a detailed description of the algorithm see\+:

\mbox{[}1\mbox{]} Loitsch, \char`\"{}\+Printing Floating-\/\+Point Numbers Quickly and Accurately with     Integers\char`\"{}, Proceedings of the ACM SIGPLAN 2010 Conference on Programming Language Design and Implementation, PLDI 2010 \mbox{[}2\mbox{]} Burger, Dybvig, \char`\"{}\+Printing Floating-\/\+Point Numbers Quickly and Accurately\char`\"{}, Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation, PLDI 1996 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_ad90f19ed10d8133b727df4b9bc5ddf5c}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_ad90f19ed10d8133b727df4b9bc5ddf5c}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!append\_exponent@{append\_exponent}}
\index{append\_exponent@{append\_exponent}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{append\_exponent()}{append\_exponent()}}
{\footnotesize\ttfamily \mbox{\hyperlink{json_8hpp_a5f2aaec3b681d0a72f7d6e90b70cdcd1}{JSON\+\_\+\+HEDLEY\+\_\+\+RETURNS\+\_\+\+NON\+\_\+\+NULL}} char$\ast$ nlohmann\+::detail\+::dtoa\+\_\+impl\+::append\+\_\+exponent (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf,  }\item[{int}]{e }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



appends a decimal representation of e to buf 

\begin{DoxyReturn}{Returns}
a pointer to the element following the exponent. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
-\/1000 $<$ e $<$ 1000 
\end{DoxyPrecond}


Definition at line 13572 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13573 \{}
\DoxyCodeLine{13574     assert(e > -\/1000);}
\DoxyCodeLine{13575     assert(e <  1000);}
\DoxyCodeLine{13576 }
\DoxyCodeLine{13577     \textcolor{keywordflow}{if} (e < 0)}
\DoxyCodeLine{13578     \{}
\DoxyCodeLine{13579         e = -\/e;}
\DoxyCodeLine{13580         *buf++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{13581     \}}
\DoxyCodeLine{13582     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13583     \{}
\DoxyCodeLine{13584         *buf++ = \textcolor{charliteral}{'+'};}
\DoxyCodeLine{13585     \}}
\DoxyCodeLine{13586 }
\DoxyCodeLine{13587     \textcolor{keyword}{auto} k = \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(e);}
\DoxyCodeLine{13588     \textcolor{keywordflow}{if} (k < 10)}
\DoxyCodeLine{13589     \{}
\DoxyCodeLine{13590         \textcolor{comment}{// Always print at least two digits in the exponent.}}
\DoxyCodeLine{13591         \textcolor{comment}{// This is for compatibility with printf("{}\%g"{}).}}
\DoxyCodeLine{13592         *buf++ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{13593         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{13594     \}}
\DoxyCodeLine{13595     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (k < 100)}
\DoxyCodeLine{13596     \{}
\DoxyCodeLine{13597         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 10);}
\DoxyCodeLine{13598         k \%= 10;}
\DoxyCodeLine{13599         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{13600     \}}
\DoxyCodeLine{13601     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13602     \{}
\DoxyCodeLine{13603         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 100);}
\DoxyCodeLine{13604         k \%= 100;}
\DoxyCodeLine{13605         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 10);}
\DoxyCodeLine{13606         k \%= 10;}
\DoxyCodeLine{13607         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{13608     \}}
\DoxyCodeLine{13609 }
\DoxyCodeLine{13610     \textcolor{keywordflow}{return} buf;}
\DoxyCodeLine{13611 \}}

\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_ad90f19ed10d8133b727df4b9bc5ddf5c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!compute\_boundaries@{compute\_boundaries}}
\index{compute\_boundaries@{compute\_boundaries}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{compute\_boundaries()}{compute\_boundaries()}}
{\footnotesize\ttfamily template$<$typename Float\+Type $>$ \\
\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1boundaries}{boundaries}} nlohmann\+::detail\+::dtoa\+\_\+impl\+::compute\+\_\+boundaries (\begin{DoxyParamCaption}\item[{Float\+Type}]{value }\end{DoxyParamCaption})}

Compute the (normalized) diyfp representing the input number \textquotesingle{}value\textquotesingle{} and its boundaries.

\begin{DoxyPrecond}{Precondition}
value must be finite and positive 
\end{DoxyPrecond}


Definition at line 12831 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{12832 \{}
\DoxyCodeLine{12833     assert(std::isfinite(value));}
\DoxyCodeLine{12834     assert(value > 0);}
\DoxyCodeLine{12835 }
\DoxyCodeLine{12836     \textcolor{comment}{// Convert the IEEE representation into a diyfp.}}
\DoxyCodeLine{12837     \textcolor{comment}{//}}
\DoxyCodeLine{12838     \textcolor{comment}{// If v is denormal:}}
\DoxyCodeLine{12839     \textcolor{comment}{//      value = 0.F * 2\string^(1 -\/ bias) = (          F) * 2\string^(1 -\/ bias -\/ (p-\/1))}}
\DoxyCodeLine{12840     \textcolor{comment}{// If v is normalized:}}
\DoxyCodeLine{12841     \textcolor{comment}{//      value = 1.F * 2\string^(E -\/ bias) = (2\string^(p-\/1) + F) * 2\string^(E -\/ bias -\/ (p-\/1))}}
\DoxyCodeLine{12842 }
\DoxyCodeLine{12843     static\_assert(std::numeric\_limits<FloatType>::is\_iec559,}
\DoxyCodeLine{12844                   \textcolor{stringliteral}{"{}internal error: dtoa\_short requires an IEEE-\/754 floating-\/point implementation"{}});}
\DoxyCodeLine{12845 }
\DoxyCodeLine{12846     constexpr \textcolor{keywordtype}{int}      kPrecision = std::numeric\_limits<FloatType>::digits; \textcolor{comment}{// = p (includes the hidden bit)}}
\DoxyCodeLine{12847     constexpr \textcolor{keywordtype}{int}      kBias      = std::numeric\_limits<FloatType>::max\_exponent -\/ 1 + (kPrecision -\/ 1);}
\DoxyCodeLine{12848     constexpr \textcolor{keywordtype}{int}      kMinExp    = 1 -\/ kBias;}
\DoxyCodeLine{12849     constexpr std::uint64\_t kHiddenBit = std::uint64\_t\{1\} << (kPrecision -\/ 1); \textcolor{comment}{// = 2\string^(p-\/1)}}
\DoxyCodeLine{12850 }
\DoxyCodeLine{12851     \textcolor{keyword}{using} bits\_type = \textcolor{keyword}{typename} std::conditional<kPrecision == 24, std::uint32\_t, std::uint64\_t >::type;}
\DoxyCodeLine{12852 }
\DoxyCodeLine{12853     \textcolor{keyword}{const} std::uint64\_t bits = reinterpret\_bits<bits\_type>(value);}
\DoxyCodeLine{12854     \textcolor{keyword}{const} std::uint64\_t E = bits >> (kPrecision -\/ 1);}
\DoxyCodeLine{12855     \textcolor{keyword}{const} std::uint64\_t F = bits \& (kHiddenBit -\/ 1);}
\DoxyCodeLine{12856 }
\DoxyCodeLine{12857     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_denormal = E == 0;}
\DoxyCodeLine{12858     \textcolor{keyword}{const} diyfp v = is\_denormal}
\DoxyCodeLine{12859                     ? diyfp(F, kMinExp)}
\DoxyCodeLine{12860                     : diyfp(F + kHiddenBit, static\_cast<int>(E) -\/ kBias);}
\DoxyCodeLine{12861 }
\DoxyCodeLine{12862     \textcolor{comment}{// Compute the boundaries m-\/ and m+ of the floating-\/point value}}
\DoxyCodeLine{12863     \textcolor{comment}{// v = f * 2\string^e.}}
\DoxyCodeLine{12864     \textcolor{comment}{//}}
\DoxyCodeLine{12865     \textcolor{comment}{// Determine v-\/ and v+, the floating-\/point predecessor and successor if v,}}
\DoxyCodeLine{12866     \textcolor{comment}{// respectively.}}
\DoxyCodeLine{12867     \textcolor{comment}{//}}
\DoxyCodeLine{12868     \textcolor{comment}{//      v-\/ = v -\/ 2\string^e        if f != 2\string^(p-\/1) or e == e\_min                (A)}}
\DoxyCodeLine{12869     \textcolor{comment}{//         = v -\/ 2\string^(e-\/1)    if f == 2\string^(p-\/1) and e > e\_min                (B)}}
\DoxyCodeLine{12870     \textcolor{comment}{//}}
\DoxyCodeLine{12871     \textcolor{comment}{//      v+ = v + 2\string^e}}
\DoxyCodeLine{12872     \textcolor{comment}{//}}
\DoxyCodeLine{12873     \textcolor{comment}{// Let m-\/ = (v-\/ + v) / 2 and m+ = (v + v+) / 2. All real numbers \_strictly\_}}
\DoxyCodeLine{12874     \textcolor{comment}{// between m-\/ and m+ round to v, regardless of how the input rounding}}
\DoxyCodeLine{12875     \textcolor{comment}{// algorithm breaks ties.}}
\DoxyCodeLine{12876     \textcolor{comment}{//}}
\DoxyCodeLine{12877     \textcolor{comment}{//      -\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/  (A)}}
\DoxyCodeLine{12878     \textcolor{comment}{//         v-\/            m-\/            v             m+            v+}}
\DoxyCodeLine{12879     \textcolor{comment}{//}}
\DoxyCodeLine{12880     \textcolor{comment}{//      -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/  (B)}}
\DoxyCodeLine{12881     \textcolor{comment}{//                       v-\/     m-\/     v             m+            v+}}
\DoxyCodeLine{12882 }
\DoxyCodeLine{12883     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} lower\_boundary\_is\_closer = F == 0 and E > 1;}
\DoxyCodeLine{12884     \textcolor{keyword}{const} diyfp m\_plus = diyfp(2 * v.f + 1, v.e -\/ 1);}
\DoxyCodeLine{12885     \textcolor{keyword}{const} diyfp m\_minus = lower\_boundary\_is\_closer}
\DoxyCodeLine{12886                           ? diyfp(4 * v.f -\/ 1, v.e -\/ 2)  \textcolor{comment}{// (B)}}
\DoxyCodeLine{12887                           : diyfp(2 * v.f -\/ 1, v.e -\/ 1); \textcolor{comment}{// (A)}}
\DoxyCodeLine{12888 }
\DoxyCodeLine{12889     \textcolor{comment}{// Determine the normalized w+ = m+.}}
\DoxyCodeLine{12890     \textcolor{keyword}{const} diyfp w\_plus = diyfp::normalize(m\_plus);}
\DoxyCodeLine{12891 }
\DoxyCodeLine{12892     \textcolor{comment}{// Determine w-\/ = m-\/ such that e\_(w-\/) = e\_(w+).}}
\DoxyCodeLine{12893     \textcolor{keyword}{const} diyfp w\_minus = diyfp::normalize\_to(m\_minus, w\_plus.e);}
\DoxyCodeLine{12894 }
\DoxyCodeLine{12895     \textcolor{keywordflow}{return} \{diyfp::normalize(v), w\_minus, w\_plus\};}
\DoxyCodeLine{12896 \}}

\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a36ded358763b5dbcea9867660fbe4e28}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a36ded358763b5dbcea9867660fbe4e28}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!find\_largest\_pow10@{find\_largest\_pow10}}
\index{find\_largest\_pow10@{find\_largest\_pow10}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{find\_largest\_pow10()}{find\_largest\_pow10()}}
{\footnotesize\ttfamily int nlohmann\+::detail\+::dtoa\+\_\+impl\+::find\+\_\+largest\+\_\+pow10 (\begin{DoxyParamCaption}\item[{const std\+::uint32\+\_\+t}]{n,  }\item[{std\+::uint32\+\_\+t \&}]{pow10 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

For n != 0, returns k, such that pow10 \+:= 10$^\wedge$(k-\/1) $<$= n $<$ 10$^\wedge$k. For n == 0, returns 1 and sets pow10 \+:= 1. 

Definition at line 13134 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13135 \{}
\DoxyCodeLine{13136     \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{13137     \textcolor{keywordflow}{if} (n >= 1000000000)}
\DoxyCodeLine{13138     \{}
\DoxyCodeLine{13139         pow10 = 1000000000;}
\DoxyCodeLine{13140         \textcolor{keywordflow}{return} 10;}
\DoxyCodeLine{13141     \}}
\DoxyCodeLine{13142     \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{13143     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 100000000)}
\DoxyCodeLine{13144     \{}
\DoxyCodeLine{13145         pow10 = 100000000;}
\DoxyCodeLine{13146         \textcolor{keywordflow}{return}  9;}
\DoxyCodeLine{13147     \}}
\DoxyCodeLine{13148     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 10000000)}
\DoxyCodeLine{13149     \{}
\DoxyCodeLine{13150         pow10 = 10000000;}
\DoxyCodeLine{13151         \textcolor{keywordflow}{return}  8;}
\DoxyCodeLine{13152     \}}
\DoxyCodeLine{13153     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 1000000)}
\DoxyCodeLine{13154     \{}
\DoxyCodeLine{13155         pow10 = 1000000;}
\DoxyCodeLine{13156         \textcolor{keywordflow}{return}  7;}
\DoxyCodeLine{13157     \}}
\DoxyCodeLine{13158     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 100000)}
\DoxyCodeLine{13159     \{}
\DoxyCodeLine{13160         pow10 = 100000;}
\DoxyCodeLine{13161         \textcolor{keywordflow}{return}  6;}
\DoxyCodeLine{13162     \}}
\DoxyCodeLine{13163     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 10000)}
\DoxyCodeLine{13164     \{}
\DoxyCodeLine{13165         pow10 = 10000;}
\DoxyCodeLine{13166         \textcolor{keywordflow}{return}  5;}
\DoxyCodeLine{13167     \}}
\DoxyCodeLine{13168     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 1000)}
\DoxyCodeLine{13169     \{}
\DoxyCodeLine{13170         pow10 = 1000;}
\DoxyCodeLine{13171         \textcolor{keywordflow}{return}  4;}
\DoxyCodeLine{13172     \}}
\DoxyCodeLine{13173     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 100)}
\DoxyCodeLine{13174     \{}
\DoxyCodeLine{13175         pow10 = 100;}
\DoxyCodeLine{13176         \textcolor{keywordflow}{return}  3;}
\DoxyCodeLine{13177     \}}
\DoxyCodeLine{13178     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 10)}
\DoxyCodeLine{13179     \{}
\DoxyCodeLine{13180         pow10 = 10;}
\DoxyCodeLine{13181         \textcolor{keywordflow}{return}  2;}
\DoxyCodeLine{13182     \}}
\DoxyCodeLine{13183     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13184     \{}
\DoxyCodeLine{13185         pow10 = 1;}
\DoxyCodeLine{13186         \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{13187     \}}
\DoxyCodeLine{13188 \}}

\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_a36ded358763b5dbcea9867660fbe4e28_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_ab441f2761e33839ca48bc2225e14a2a9}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_ab441f2761e33839ca48bc2225e14a2a9}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!format\_buffer@{format\_buffer}}
\index{format\_buffer@{format\_buffer}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{format\_buffer()}{format\_buffer()}}
{\footnotesize\ttfamily \mbox{\hyperlink{json_8hpp_a5f2aaec3b681d0a72f7d6e90b70cdcd1}{JSON\+\_\+\+HEDLEY\+\_\+\+RETURNS\+\_\+\+NON\+\_\+\+NULL}} char$\ast$ nlohmann\+::detail\+::dtoa\+\_\+impl\+::format\+\_\+buffer (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf,  }\item[{int}]{len,  }\item[{int}]{decimal\+\_\+exponent,  }\item[{int}]{min\+\_\+exp,  }\item[{int}]{max\+\_\+exp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



prettify v = buf $\ast$ 10$^\wedge$decimal\+\_\+exponent 

If v is in the range \mbox{[}10$^\wedge$min\+\_\+exp, 10$^\wedge$max\+\_\+exp) it will be printed in fixed-\/point notation. Otherwise it will be printed in exponential notation.

\begin{DoxyPrecond}{Precondition}
min\+\_\+exp $<$ 0 

max\+\_\+exp $>$ 0 
\end{DoxyPrecond}


Definition at line 13624 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13626 \{}
\DoxyCodeLine{13627     assert(min\_exp < 0);}
\DoxyCodeLine{13628     assert(max\_exp > 0);}
\DoxyCodeLine{13629 }
\DoxyCodeLine{13630     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = len;}
\DoxyCodeLine{13631     \textcolor{keyword}{const} \textcolor{keywordtype}{int} n = len + decimal\_exponent;}
\DoxyCodeLine{13632 }
\DoxyCodeLine{13633     \textcolor{comment}{// v = buf * 10\string^(n-\/k)}}
\DoxyCodeLine{13634     \textcolor{comment}{// k is the length of the buffer (number of decimal digits)}}
\DoxyCodeLine{13635     \textcolor{comment}{// n is the position of the decimal point relative to the start of the buffer.}}
\DoxyCodeLine{13636 }
\DoxyCodeLine{13637     \textcolor{keywordflow}{if} (k <= n and n <= max\_exp)}
\DoxyCodeLine{13638     \{}
\DoxyCodeLine{13639         \textcolor{comment}{// digits[000]}}
\DoxyCodeLine{13640         \textcolor{comment}{// len <= max\_exp + 2}}
\DoxyCodeLine{13641 }
\DoxyCodeLine{13642         std::memset(buf + k, \textcolor{charliteral}{'0'}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n -\/ k));}
\DoxyCodeLine{13643         \textcolor{comment}{// Make it look like a floating-\/point number (\#362, \#378)}}
\DoxyCodeLine{13644         buf[n + 0] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{13645         buf[n + 1] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{13646         \textcolor{keywordflow}{return} buf + (n + 2);}
\DoxyCodeLine{13647     \}}
\DoxyCodeLine{13648 }
\DoxyCodeLine{13649     \textcolor{keywordflow}{if} (0 < n and n <= max\_exp)}
\DoxyCodeLine{13650     \{}
\DoxyCodeLine{13651         \textcolor{comment}{// dig.its}}
\DoxyCodeLine{13652         \textcolor{comment}{// len <= max\_digits10 + 1}}
\DoxyCodeLine{13653 }
\DoxyCodeLine{13654         assert(k > n);}
\DoxyCodeLine{13655 }
\DoxyCodeLine{13656         std::memmove(buf + (n + 1), buf + n, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k -\/ n));}
\DoxyCodeLine{13657         buf[n] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{13658         \textcolor{keywordflow}{return} buf + (k + 1);}
\DoxyCodeLine{13659     \}}
\DoxyCodeLine{13660 }
\DoxyCodeLine{13661     \textcolor{keywordflow}{if} (min\_exp < n and n <= 0)}
\DoxyCodeLine{13662     \{}
\DoxyCodeLine{13663         \textcolor{comment}{// 0.[000]digits}}
\DoxyCodeLine{13664         \textcolor{comment}{// len <= 2 + (-\/min\_exp -\/ 1) + max\_digits10}}
\DoxyCodeLine{13665 }
\DoxyCodeLine{13666         std::memmove(buf + (2 + -\/n), buf, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k));}
\DoxyCodeLine{13667         buf[0] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{13668         buf[1] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{13669         std::memset(buf + 2, \textcolor{charliteral}{'0'}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(-\/n));}
\DoxyCodeLine{13670         \textcolor{keywordflow}{return} buf + (2 + (-\/n) + k);}
\DoxyCodeLine{13671     \}}
\DoxyCodeLine{13672 }
\DoxyCodeLine{13673     \textcolor{keywordflow}{if} (k == 1)}
\DoxyCodeLine{13674     \{}
\DoxyCodeLine{13675         \textcolor{comment}{// dE+123}}
\DoxyCodeLine{13676         \textcolor{comment}{// len <= 1 + 5}}
\DoxyCodeLine{13677 }
\DoxyCodeLine{13678         buf += 1;}
\DoxyCodeLine{13679     \}}
\DoxyCodeLine{13680     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13681     \{}
\DoxyCodeLine{13682         \textcolor{comment}{// d.igitsE+123}}
\DoxyCodeLine{13683         \textcolor{comment}{// len <= max\_digits10 + 1 + 5}}
\DoxyCodeLine{13684 }
\DoxyCodeLine{13685         std::memmove(buf + 2, buf + 1, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k -\/ 1));}
\DoxyCodeLine{13686         buf[1] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{13687         buf += 1 + k;}
\DoxyCodeLine{13688     \}}
\DoxyCodeLine{13689 }
\DoxyCodeLine{13690     *buf++ = \textcolor{charliteral}{'e'};}
\DoxyCodeLine{13691     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_ad90f19ed10d8133b727df4b9bc5ddf5c}{append\_exponent}}(buf, n -\/ 1);}
\DoxyCodeLine{13692 \}}

\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_ab441f2761e33839ca48bc2225e14a2a9_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_ab441f2761e33839ca48bc2225e14a2a9_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_adbf329a18c5cf854a3477327afd2200b}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_adbf329a18c5cf854a3477327afd2200b}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!get\_cached\_power\_for\_binary\_exponent@{get\_cached\_power\_for\_binary\_exponent}}
\index{get\_cached\_power\_for\_binary\_exponent@{get\_cached\_power\_for\_binary\_exponent}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{get\_cached\_power\_for\_binary\_exponent()}{get\_cached\_power\_for\_binary\_exponent()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1cached__power}{cached\+\_\+power}} nlohmann\+::detail\+::dtoa\+\_\+impl\+::get\+\_\+cached\+\_\+power\+\_\+for\+\_\+binary\+\_\+exponent (\begin{DoxyParamCaption}\item[{int}]{e }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

For a normalized diyfp w = f $\ast$ 2$^\wedge$e, this function returns a (normalized) cached power-\/of-\/ten c = f\+\_\+c $\ast$ 2$^\wedge$e\+\_\+c, such that the exponent of the product w $\ast$ c satisfies (Definition 3.\+2 from \mbox{[}1\mbox{]}) \begin{DoxyVerb} alpha <= e_c + e + q <= gamma.
\end{DoxyVerb}
 

Definition at line 12970 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{12971 \{}
\DoxyCodeLine{12972     \textcolor{comment}{// Now}}
\DoxyCodeLine{12973     \textcolor{comment}{//}}
\DoxyCodeLine{12974     \textcolor{comment}{//      alpha <= e\_c + e + q <= gamma                                    (1)}}
\DoxyCodeLine{12975     \textcolor{comment}{//      ==> f\_c * 2\string^alpha <= c * 2\string^e * 2\string^q}}
\DoxyCodeLine{12976     \textcolor{comment}{//}}
\DoxyCodeLine{12977     \textcolor{comment}{// and since the c's are normalized, 2\string^(q-\/1) <= f\_c,}}
\DoxyCodeLine{12978     \textcolor{comment}{//}}
\DoxyCodeLine{12979     \textcolor{comment}{//      ==> 2\string^(q -\/ 1 + alpha) <= c * 2\string^(e + q)}}
\DoxyCodeLine{12980     \textcolor{comment}{//      ==> 2\string^(alpha -\/ e -\/ 1) <= c}}
\DoxyCodeLine{12981     \textcolor{comment}{//}}
\DoxyCodeLine{12982     \textcolor{comment}{// If c were an exact power of ten, i.e. c = 10\string^k, one may determine k as}}
\DoxyCodeLine{12983     \textcolor{comment}{//}}
\DoxyCodeLine{12984     \textcolor{comment}{//      k = ceil( log\_10( 2\string^(alpha -\/ e -\/ 1) ) )}}
\DoxyCodeLine{12985     \textcolor{comment}{//        = ceil( (alpha -\/ e -\/ 1) * log\_10(2) )}}
\DoxyCodeLine{12986     \textcolor{comment}{//}}
\DoxyCodeLine{12987     \textcolor{comment}{// From the paper:}}
\DoxyCodeLine{12988     \textcolor{comment}{// "{}In theory the result of the procedure could be wrong since c is rounded,}}
\DoxyCodeLine{12989     \textcolor{comment}{//  and the computation itself is approximated [...]. In practice, however,}}
\DoxyCodeLine{12990     \textcolor{comment}{//  this simple function is sufficient."{}}}
\DoxyCodeLine{12991     \textcolor{comment}{//}}
\DoxyCodeLine{12992     \textcolor{comment}{// For IEEE double precision floating-\/point numbers converted into}}
\DoxyCodeLine{12993     \textcolor{comment}{// normalized diyfp's w = f * 2\string^e, with q = 64,}}
\DoxyCodeLine{12994     \textcolor{comment}{//}}
\DoxyCodeLine{12995     \textcolor{comment}{//      e >= -\/1022      (min IEEE exponent)}}
\DoxyCodeLine{12996     \textcolor{comment}{//           -\/52        (p -\/ 1)}}
\DoxyCodeLine{12997     \textcolor{comment}{//           -\/52        (p -\/ 1, possibly normalize denormal IEEE numbers)}}
\DoxyCodeLine{12998     \textcolor{comment}{//           -\/11        (normalize the diyfp)}}
\DoxyCodeLine{12999     \textcolor{comment}{//         = -\/1137}}
\DoxyCodeLine{13000     \textcolor{comment}{//}}
\DoxyCodeLine{13001     \textcolor{comment}{// and}}
\DoxyCodeLine{13002     \textcolor{comment}{//}}
\DoxyCodeLine{13003     \textcolor{comment}{//      e <= +1023      (max IEEE exponent)}}
\DoxyCodeLine{13004     \textcolor{comment}{//           -\/52        (p -\/ 1)}}
\DoxyCodeLine{13005     \textcolor{comment}{//           -\/11        (normalize the diyfp)}}
\DoxyCodeLine{13006     \textcolor{comment}{//         = 960}}
\DoxyCodeLine{13007     \textcolor{comment}{//}}
\DoxyCodeLine{13008     \textcolor{comment}{// This binary exponent range [-\/1137,960] results in a decimal exponent}}
\DoxyCodeLine{13009     \textcolor{comment}{// range [-\/307,324]. One does not need to store a cached power for each}}
\DoxyCodeLine{13010     \textcolor{comment}{// k in this range. For each such k it suffices to find a cached power}}
\DoxyCodeLine{13011     \textcolor{comment}{// such that the exponent of the product lies in [alpha,gamma].}}
\DoxyCodeLine{13012     \textcolor{comment}{// This implies that the difference of the decimal exponents of adjacent}}
\DoxyCodeLine{13013     \textcolor{comment}{// table entries must be less than or equal to}}
\DoxyCodeLine{13014     \textcolor{comment}{//}}
\DoxyCodeLine{13015     \textcolor{comment}{//      floor( (gamma -\/ alpha) * log\_10(2) ) = 8.}}
\DoxyCodeLine{13016     \textcolor{comment}{//}}
\DoxyCodeLine{13017     \textcolor{comment}{// (A smaller distance gamma-\/alpha would require a larger table.)}}
\DoxyCodeLine{13018 }
\DoxyCodeLine{13019     \textcolor{comment}{// NB:}}
\DoxyCodeLine{13020     \textcolor{comment}{// Actually this function returns c, such that -\/60 <= e\_c + e + 64 <= -\/34.}}
\DoxyCodeLine{13021 }
\DoxyCodeLine{13022     constexpr \textcolor{keywordtype}{int} kCachedPowersMinDecExp = -\/300;}
\DoxyCodeLine{13023     constexpr \textcolor{keywordtype}{int} kCachedPowersDecStep = 8;}
\DoxyCodeLine{13024 }
\DoxyCodeLine{13025     \textcolor{keyword}{static} constexpr std::array<cached\_power, 79> kCachedPowers =}
\DoxyCodeLine{13026     \{}
\DoxyCodeLine{13027         \{}
\DoxyCodeLine{13028             \{ 0xAB70FE17C79AC6CA, -\/1060, -\/300 \},}
\DoxyCodeLine{13029             \{ 0xFF77B1FCBEBCDC4F, -\/1034, -\/292 \},}
\DoxyCodeLine{13030             \{ 0xBE5691EF416BD60C, -\/1007, -\/284 \},}
\DoxyCodeLine{13031             \{ 0x8DD01FAD907FFC3C,  -\/980, -\/276 \},}
\DoxyCodeLine{13032             \{ 0xD3515C2831559A83,  -\/954, -\/268 \},}
\DoxyCodeLine{13033             \{ 0x9D71AC8FADA6C9B5,  -\/927, -\/260 \},}
\DoxyCodeLine{13034             \{ 0xEA9C227723EE8BCB,  -\/901, -\/252 \},}
\DoxyCodeLine{13035             \{ 0xAECC49914078536D,  -\/874, -\/244 \},}
\DoxyCodeLine{13036             \{ 0x823C12795DB6CE57,  -\/847, -\/236 \},}
\DoxyCodeLine{13037             \{ 0xC21094364DFB5637,  -\/821, -\/228 \},}
\DoxyCodeLine{13038             \{ 0x9096EA6F3848984F,  -\/794, -\/220 \},}
\DoxyCodeLine{13039             \{ 0xD77485CB25823AC7,  -\/768, -\/212 \},}
\DoxyCodeLine{13040             \{ 0xA086CFCD97BF97F4,  -\/741, -\/204 \},}
\DoxyCodeLine{13041             \{ 0xEF340A98172AACE5,  -\/715, -\/196 \},}
\DoxyCodeLine{13042             \{ 0xB23867FB2A35B28E,  -\/688, -\/188 \},}
\DoxyCodeLine{13043             \{ 0x84C8D4DFD2C63F3B,  -\/661, -\/180 \},}
\DoxyCodeLine{13044             \{ 0xC5DD44271AD3CDBA,  -\/635, -\/172 \},}
\DoxyCodeLine{13045             \{ 0x936B9FCEBB25C996,  -\/608, -\/164 \},}
\DoxyCodeLine{13046             \{ 0xDBAC6C247D62A584,  -\/582, -\/156 \},}
\DoxyCodeLine{13047             \{ 0xA3AB66580D5FDAF6,  -\/555, -\/148 \},}
\DoxyCodeLine{13048             \{ 0xF3E2F893DEC3F126,  -\/529, -\/140 \},}
\DoxyCodeLine{13049             \{ 0xB5B5ADA8AAFF80B8,  -\/502, -\/132 \},}
\DoxyCodeLine{13050             \{ 0x87625F056C7C4A8B,  -\/475, -\/124 \},}
\DoxyCodeLine{13051             \{ 0xC9BCFF6034C13053,  -\/449, -\/116 \},}
\DoxyCodeLine{13052             \{ 0x964E858C91BA2655,  -\/422, -\/108 \},}
\DoxyCodeLine{13053             \{ 0xDFF9772470297EBD,  -\/396, -\/100 \},}
\DoxyCodeLine{13054             \{ 0xA6DFBD9FB8E5B88F,  -\/369,  -\/92 \},}
\DoxyCodeLine{13055             \{ 0xF8A95FCF88747D94,  -\/343,  -\/84 \},}
\DoxyCodeLine{13056             \{ 0xB94470938FA89BCF,  -\/316,  -\/76 \},}
\DoxyCodeLine{13057             \{ 0x8A08F0F8BF0F156B,  -\/289,  -\/68 \},}
\DoxyCodeLine{13058             \{ 0xCDB02555653131B6,  -\/263,  -\/60 \},}
\DoxyCodeLine{13059             \{ 0x993FE2C6D07B7FAC,  -\/236,  -\/52 \},}
\DoxyCodeLine{13060             \{ 0xE45C10C42A2B3B06,  -\/210,  -\/44 \},}
\DoxyCodeLine{13061             \{ 0xAA242499697392D3,  -\/183,  -\/36 \},}
\DoxyCodeLine{13062             \{ 0xFD87B5F28300CA0E,  -\/157,  -\/28 \},}
\DoxyCodeLine{13063             \{ 0xBCE5086492111AEB,  -\/130,  -\/20 \},}
\DoxyCodeLine{13064             \{ 0x8CBCCC096F5088CC,  -\/103,  -\/12 \},}
\DoxyCodeLine{13065             \{ 0xD1B71758E219652C,   -\/77,   -\/4 \},}
\DoxyCodeLine{13066             \{ 0x9C40000000000000,   -\/50,    4 \},}
\DoxyCodeLine{13067             \{ 0xE8D4A51000000000,   -\/24,   12 \},}
\DoxyCodeLine{13068             \{ 0xAD78EBC5AC620000,     3,   20 \},}
\DoxyCodeLine{13069             \{ 0x813F3978F8940984,    30,   28 \},}
\DoxyCodeLine{13070             \{ 0xC097CE7BC90715B3,    56,   36 \},}
\DoxyCodeLine{13071             \{ 0x8F7E32CE7BEA5C70,    83,   44 \},}
\DoxyCodeLine{13072             \{ 0xD5D238A4ABE98068,   109,   52 \},}
\DoxyCodeLine{13073             \{ 0x9F4F2726179A2245,   136,   60 \},}
\DoxyCodeLine{13074             \{ 0xED63A231D4C4FB27,   162,   68 \},}
\DoxyCodeLine{13075             \{ 0xB0DE65388CC8ADA8,   189,   76 \},}
\DoxyCodeLine{13076             \{ 0x83C7088E1AAB65DB,   216,   84 \},}
\DoxyCodeLine{13077             \{ 0xC45D1DF942711D9A,   242,   92 \},}
\DoxyCodeLine{13078             \{ 0x924D692CA61BE758,   269,  100 \},}
\DoxyCodeLine{13079             \{ 0xDA01EE641A708DEA,   295,  108 \},}
\DoxyCodeLine{13080             \{ 0xA26DA3999AEF774A,   322,  116 \},}
\DoxyCodeLine{13081             \{ 0xF209787BB47D6B85,   348,  124 \},}
\DoxyCodeLine{13082             \{ 0xB454E4A179DD1877,   375,  132 \},}
\DoxyCodeLine{13083             \{ 0x865B86925B9BC5C2,   402,  140 \},}
\DoxyCodeLine{13084             \{ 0xC83553C5C8965D3D,   428,  148 \},}
\DoxyCodeLine{13085             \{ 0x952AB45CFA97A0B3,   455,  156 \},}
\DoxyCodeLine{13086             \{ 0xDE469FBD99A05FE3,   481,  164 \},}
\DoxyCodeLine{13087             \{ 0xA59BC234DB398C25,   508,  172 \},}
\DoxyCodeLine{13088             \{ 0xF6C69A72A3989F5C,   534,  180 \},}
\DoxyCodeLine{13089             \{ 0xB7DCBF5354E9BECE,   561,  188 \},}
\DoxyCodeLine{13090             \{ 0x88FCF317F22241E2,   588,  196 \},}
\DoxyCodeLine{13091             \{ 0xCC20CE9BD35C78A5,   614,  204 \},}
\DoxyCodeLine{13092             \{ 0x98165AF37B2153DF,   641,  212 \},}
\DoxyCodeLine{13093             \{ 0xE2A0B5DC971F303A,   667,  220 \},}
\DoxyCodeLine{13094             \{ 0xA8D9D1535CE3B396,   694,  228 \},}
\DoxyCodeLine{13095             \{ 0xFB9B7CD9A4A7443C,   720,  236 \},}
\DoxyCodeLine{13096             \{ 0xBB764C4CA7A44410,   747,  244 \},}
\DoxyCodeLine{13097             \{ 0x8BAB8EEFB6409C1A,   774,  252 \},}
\DoxyCodeLine{13098             \{ 0xD01FEF10A657842C,   800,  260 \},}
\DoxyCodeLine{13099             \{ 0x9B10A4E5E9913129,   827,  268 \},}
\DoxyCodeLine{13100             \{ 0xE7109BFBA19C0C9D,   853,  276 \},}
\DoxyCodeLine{13101             \{ 0xAC2820D9623BF429,   880,  284 \},}
\DoxyCodeLine{13102             \{ 0x80444B5E7AA7CF85,   907,  292 \},}
\DoxyCodeLine{13103             \{ 0xBF21E44003ACDD2D,   933,  300 \},}
\DoxyCodeLine{13104             \{ 0x8E679C2F5E44FF8F,   960,  308 \},}
\DoxyCodeLine{13105             \{ 0xD433179D9C8CB841,   986,  316 \},}
\DoxyCodeLine{13106             \{ 0x9E19DB92B4E31BA9,  1013,  324 \},}
\DoxyCodeLine{13107         \}}
\DoxyCodeLine{13108     \};}
\DoxyCodeLine{13109 }
\DoxyCodeLine{13110     \textcolor{comment}{// This computation gives exactly the same results for k as}}
\DoxyCodeLine{13111     \textcolor{comment}{//      k = ceil((kAlpha -\/ e -\/ 1) * 0.30102999566398114)}}
\DoxyCodeLine{13112     \textcolor{comment}{// for |e| <= 1500, but doesn't require floating-\/point operations.}}
\DoxyCodeLine{13113     \textcolor{comment}{// NB: log\_10(2) \string~= 78913 / 2\string^18}}
\DoxyCodeLine{13114     assert(e >= -\/1500);}
\DoxyCodeLine{13115     assert(e <=  1500);}
\DoxyCodeLine{13116     \textcolor{keyword}{const} \textcolor{keywordtype}{int} f = \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_ac1ea1316de0b4a219f707c76b1db1966}{kAlpha}} -\/ e -\/ 1;}
\DoxyCodeLine{13117     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = (f * 78913) / (1 << 18) + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(f > 0);}
\DoxyCodeLine{13118 }
\DoxyCodeLine{13119     \textcolor{keyword}{const} \textcolor{keywordtype}{int} index = (-\/kCachedPowersMinDecExp + k + (kCachedPowersDecStep -\/ 1)) / kCachedPowersDecStep;}
\DoxyCodeLine{13120     assert(index >= 0);}
\DoxyCodeLine{13121     assert(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(index) < kCachedPowers.size());}
\DoxyCodeLine{13122 }
\DoxyCodeLine{13123     \textcolor{keyword}{const} cached\_power cached = kCachedPowers[\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(index)];}
\DoxyCodeLine{13124     assert(\mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_ac1ea1316de0b4a219f707c76b1db1966}{kAlpha}} <= cached.e + e + 64);}
\DoxyCodeLine{13125     assert(\mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a4a750fcc38da1ce68b7e25ab3a230e20}{kGamma}} >= cached.e + e + 64);}
\DoxyCodeLine{13126 }
\DoxyCodeLine{13127     \textcolor{keywordflow}{return} cached;}
\DoxyCodeLine{13128 \}}

\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_adbf329a18c5cf854a3477327afd2200b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a05b681dcb8569b9784c6dccfadb01633}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a05b681dcb8569b9784c6dccfadb01633}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!grisu2@{grisu2}}
\index{grisu2@{grisu2}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{grisu2()}{grisu2()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void nlohmann\+::detail\+::dtoa\+\_\+impl\+::grisu2 (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf,  }\item[{int \&}]{len,  }\item[{int \&}]{decimal\+\_\+exponent,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{m\+\_\+minus,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{v,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{m\+\_\+plus }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

v = buf $\ast$ 10$^\wedge$decimal\+\_\+exponent len is the length of the buffer (number of decimal digits) The buffer must be large enough, i.\+e. $>$= max\+\_\+digits10. 

Definition at line 13472 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13474 \{}
\DoxyCodeLine{13475     assert(m\_plus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_ae22e170815983961447c429f324c944d}{e}} == m\_minus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_ae22e170815983961447c429f324c944d}{e}});}
\DoxyCodeLine{13476     assert(m\_plus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_ae22e170815983961447c429f324c944d}{e}} == v.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_ae22e170815983961447c429f324c944d}{e}});}
\DoxyCodeLine{13477 }
\DoxyCodeLine{13478     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/    (A)}}
\DoxyCodeLine{13479     \textcolor{comment}{//          m-\/                      v                       m+}}
\DoxyCodeLine{13480     \textcolor{comment}{//}}
\DoxyCodeLine{13481     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/    (B)}}
\DoxyCodeLine{13482     \textcolor{comment}{//                      m-\/          v                       m+}}
\DoxyCodeLine{13483     \textcolor{comment}{//}}
\DoxyCodeLine{13484     \textcolor{comment}{// First scale v (and m-\/ and m+) such that the exponent is in the range}}
\DoxyCodeLine{13485     \textcolor{comment}{// [alpha, gamma].}}
\DoxyCodeLine{13486 }
\DoxyCodeLine{13487     \textcolor{keyword}{const} \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1cached__power}{cached\_power}} cached = \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_adbf329a18c5cf854a3477327afd2200b}{get\_cached\_power\_for\_binary\_exponent}}(m\_plus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_ae22e170815983961447c429f324c944d}{e}});}
\DoxyCodeLine{13488 }
\DoxyCodeLine{13489     \textcolor{keyword}{const} \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} c\_minus\_k(cached.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1cached__power_a21ae81f515f5b08d5bf423775ee56074}{f}}, cached.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1cached__power_a9e89bc89bb7bf4361f43ea27eed91d23}{e}}); \textcolor{comment}{// = c \string~= 10\string^-\/k}}
\DoxyCodeLine{13490 }
\DoxyCodeLine{13491     \textcolor{comment}{// The exponent of the products is = v.e + c\_minus\_k.e + q and is in the range [alpha,gamma]}}
\DoxyCodeLine{13492     \textcolor{keyword}{const} \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} w       = diyfp::mul(v,       c\_minus\_k);}
\DoxyCodeLine{13493     \textcolor{keyword}{const} \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} w\_minus = diyfp::mul(m\_minus, c\_minus\_k);}
\DoxyCodeLine{13494     \textcolor{keyword}{const} \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} w\_plus  = diyfp::mul(m\_plus,  c\_minus\_k);}
\DoxyCodeLine{13495 }
\DoxyCodeLine{13496     \textcolor{comment}{//  -\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/}}
\DoxyCodeLine{13497     \textcolor{comment}{//          w-\/                      w                       w+}}
\DoxyCodeLine{13498     \textcolor{comment}{//          = c*m-\/                  = c*v                   = c*m+}}
\DoxyCodeLine{13499     \textcolor{comment}{//}}
\DoxyCodeLine{13500     \textcolor{comment}{// diyfp::mul rounds its result and c\_minus\_k is approximated too. w, w-\/ and}}
\DoxyCodeLine{13501     \textcolor{comment}{// w+ are now off by a small amount.}}
\DoxyCodeLine{13502     \textcolor{comment}{// In fact:}}
\DoxyCodeLine{13503     \textcolor{comment}{//}}
\DoxyCodeLine{13504     \textcolor{comment}{//      w -\/ v * 10\string^k < 1 ulp}}
\DoxyCodeLine{13505     \textcolor{comment}{//}}
\DoxyCodeLine{13506     \textcolor{comment}{// To account for this inaccuracy, add resp. subtract 1 ulp.}}
\DoxyCodeLine{13507     \textcolor{comment}{//}}
\DoxyCodeLine{13508     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{13509     \textcolor{comment}{//          w-\/  M-\/                  w                   M+  w+}}
\DoxyCodeLine{13510     \textcolor{comment}{//}}
\DoxyCodeLine{13511     \textcolor{comment}{// Now any number in [M-\/, M+] (bounds included) will round to w when input,}}
\DoxyCodeLine{13512     \textcolor{comment}{// regardless of how the input rounding algorithm breaks ties.}}
\DoxyCodeLine{13513     \textcolor{comment}{//}}
\DoxyCodeLine{13514     \textcolor{comment}{// And digit\_gen generates the shortest possible such number in [M-\/, M+].}}
\DoxyCodeLine{13515     \textcolor{comment}{// Note that this does not mean that Grisu2 always generates the shortest}}
\DoxyCodeLine{13516     \textcolor{comment}{// possible number in the interval (m-\/, m+).}}
\DoxyCodeLine{13517     \textcolor{keyword}{const} \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\_minus(w\_minus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_aea90459e340a231ca31d46946803ef51}{f}} + 1, w\_minus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_ae22e170815983961447c429f324c944d}{e}});}
\DoxyCodeLine{13518     \textcolor{keyword}{const} \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\_plus (w\_plus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_aea90459e340a231ca31d46946803ef51}{f}}  -\/ 1, w\_plus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_ae22e170815983961447c429f324c944d}{e}} );}
\DoxyCodeLine{13519 }
\DoxyCodeLine{13520     decimal\_exponent = -\/cached.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1cached__power_a8c1f2efed643eeaa8fae83c697a29c6a}{k}}; \textcolor{comment}{// = -\/(-\/k) = k}}
\DoxyCodeLine{13521 }
\DoxyCodeLine{13522     \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a9b899c72b0e1e3dd46d75c2b4e6bcdfb}{grisu2\_digit\_gen}}(buf, len, decimal\_exponent, M\_minus, w, M\_plus);}
\DoxyCodeLine{13523 \}}

\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_a05b681dcb8569b9784c6dccfadb01633_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_a05b681dcb8569b9784c6dccfadb01633_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_aab7a9670a4f4704a5d0347ad7588576b}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_aab7a9670a4f4704a5d0347ad7588576b}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!grisu2@{grisu2}}
\index{grisu2@{grisu2}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{grisu2()}{grisu2()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Float\+Type $>$ \\
void nlohmann\+::detail\+::dtoa\+\_\+impl\+::grisu2 (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf,  }\item[{int \&}]{len,  }\item[{int \&}]{decimal\+\_\+exponent,  }\item[{Float\+Type}]{value }\end{DoxyParamCaption})}

v = buf $\ast$ 10$^\wedge$decimal\+\_\+exponent len is the length of the buffer (number of decimal digits) The buffer must be large enough, i.\+e. $>$= max\+\_\+digits10. 

Definition at line 13532 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13533 \{}
\DoxyCodeLine{13534     static\_assert(diyfp::kPrecision >= std::numeric\_limits<FloatType>::digits + 3,}
\DoxyCodeLine{13535                   \textcolor{stringliteral}{"{}internal error: not enough precision"{}});}
\DoxyCodeLine{13536 }
\DoxyCodeLine{13537     assert(std::isfinite(value));}
\DoxyCodeLine{13538     assert(value > 0);}
\DoxyCodeLine{13539 }
\DoxyCodeLine{13540     \textcolor{comment}{// If the neighbors (and boundaries) of 'value' are always computed for double-\/precision}}
\DoxyCodeLine{13541     \textcolor{comment}{// numbers, all float's can be recovered using strtod (and strtof). However, the resulting}}
\DoxyCodeLine{13542     \textcolor{comment}{// decimal representations are not exactly "{}short"{}.}}
\DoxyCodeLine{13543     \textcolor{comment}{//}}
\DoxyCodeLine{13544     \textcolor{comment}{// The documentation for 'std::to\_chars' (https://en.cppreference.com/w/cpp/utility/to\_chars)}}
\DoxyCodeLine{13545     \textcolor{comment}{// says "{}value is converted to a string as if by std::sprintf in the default ("{}C"{}) locale"{}}}
\DoxyCodeLine{13546     \textcolor{comment}{// and since sprintf promotes float's to double's, I think this is exactly what 'std::to\_chars'}}
\DoxyCodeLine{13547     \textcolor{comment}{// does.}}
\DoxyCodeLine{13548     \textcolor{comment}{// On the other hand, the documentation for 'std::to\_chars' requires that "{}parsing the}}
\DoxyCodeLine{13549     \textcolor{comment}{// representation using the corresponding std::from\_chars function recovers value exactly"{}. That}}
\DoxyCodeLine{13550     \textcolor{comment}{// indicates that single precision floating-\/point numbers should be recovered using}}
\DoxyCodeLine{13551     \textcolor{comment}{// 'std::strtof'.}}
\DoxyCodeLine{13552     \textcolor{comment}{//}}
\DoxyCodeLine{13553     \textcolor{comment}{// NB: If the neighbors are computed for single-\/precision numbers, there is a single float}}
\DoxyCodeLine{13554     \textcolor{comment}{//     (7.0385307e-\/26f) which can't be recovered using strtod. The resulting double precision}}
\DoxyCodeLine{13555     \textcolor{comment}{//     value is off by 1 ulp.}}
\DoxyCodeLine{13556 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{13557     \textcolor{keyword}{const} \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1boundaries}{boundaries}} w = \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded}{compute\_boundaries}}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{13558 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{13559     \textcolor{keyword}{const} \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1boundaries}{boundaries}} w = \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded}{compute\_boundaries}}(value);}
\DoxyCodeLine{13560 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13561 }
\DoxyCodeLine{13562     \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_aab7a9670a4f4704a5d0347ad7588576b}{grisu2}}(buf, len, decimal\_exponent, w.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1boundaries_aec4e5028333c01f3229062f31ce16763}{minus}}, w.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1boundaries_ad1668c60aeade5f2557fafed8b8aee1a}{w}}, w.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1boundaries_a3321ae2816a6ec5250a0d8e29f798232}{plus}});}
\DoxyCodeLine{13563 \}}

\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_aab7a9670a4f4704a5d0347ad7588576b_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a9b899c72b0e1e3dd46d75c2b4e6bcdfb}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a9b899c72b0e1e3dd46d75c2b4e6bcdfb}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!grisu2\_digit\_gen@{grisu2\_digit\_gen}}
\index{grisu2\_digit\_gen@{grisu2\_digit\_gen}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{grisu2\_digit\_gen()}{grisu2\_digit\_gen()}}
{\footnotesize\ttfamily void nlohmann\+::detail\+::dtoa\+\_\+impl\+::grisu2\+\_\+digit\+\_\+gen (\begin{DoxyParamCaption}\item[{char $\ast$}]{buffer,  }\item[{int \&}]{length,  }\item[{int \&}]{decimal\+\_\+exponent,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{M\+\_\+minus,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{w,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{M\+\_\+plus }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Generates V = buffer $\ast$ 10$^\wedge$decimal\+\_\+exponent, such that M-\/ $<$= V $<$= M+. M-\/ and M+ must be normalized and share the same exponent -\/60 $<$= e $<$= -\/32. 

Definition at line 13231 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13233 \{}
\DoxyCodeLine{13234     static\_assert(\mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_ac1ea1316de0b4a219f707c76b1db1966}{kAlpha}} >= -\/60, \textcolor{stringliteral}{"{}internal error"{}});}
\DoxyCodeLine{13235     static\_assert(\mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a4a750fcc38da1ce68b7e25ab3a230e20}{kGamma}} <= -\/32, \textcolor{stringliteral}{"{}internal error"{}});}
\DoxyCodeLine{13236 }
\DoxyCodeLine{13237     \textcolor{comment}{// Generates the digits (and the exponent) of a decimal floating-\/point}}
\DoxyCodeLine{13238     \textcolor{comment}{// number V = buffer * 10\string^decimal\_exponent in the range [M-\/, M+]. The diyfp's}}
\DoxyCodeLine{13239     \textcolor{comment}{// w, M-\/ and M+ share the same exponent e, which satisfies alpha <= e <= gamma.}}
\DoxyCodeLine{13240     \textcolor{comment}{//}}
\DoxyCodeLine{13241     \textcolor{comment}{//               <-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ delta -\/-\/-\/-\/>}}
\DoxyCodeLine{13242     \textcolor{comment}{//                                  <-\/-\/-\/-\/ dist -\/-\/-\/-\/-\/-\/-\/-\/-\/>}}
\DoxyCodeLine{13243     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{13244     \textcolor{comment}{//               M-\/                 w                   M+}}
\DoxyCodeLine{13245     \textcolor{comment}{//}}
\DoxyCodeLine{13246     \textcolor{comment}{// Grisu2 generates the digits of M+ from left to right and stops as soon as}}
\DoxyCodeLine{13247     \textcolor{comment}{// V is in [M-\/,M+].}}
\DoxyCodeLine{13248 }
\DoxyCodeLine{13249     assert(M\_plus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_ae22e170815983961447c429f324c944d}{e}} >= \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_ac1ea1316de0b4a219f707c76b1db1966}{kAlpha}});}
\DoxyCodeLine{13250     assert(M\_plus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_ae22e170815983961447c429f324c944d}{e}} <= \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a4a750fcc38da1ce68b7e25ab3a230e20}{kGamma}});}
\DoxyCodeLine{13251 }
\DoxyCodeLine{13252     std::uint64\_t delta = diyfp::sub(M\_plus, M\_minus).f; \textcolor{comment}{// (significand of (M+ -\/ M-\/), implicit exponent is e)}}
\DoxyCodeLine{13253     std::uint64\_t dist  = diyfp::sub(M\_plus, w      ).f; \textcolor{comment}{// (significand of (M+ -\/ w ), implicit exponent is e)}}
\DoxyCodeLine{13254 }
\DoxyCodeLine{13255     \textcolor{comment}{// Split M+ = f * 2\string^e into two parts p1 and p2 (note: e < 0):}}
\DoxyCodeLine{13256     \textcolor{comment}{//}}
\DoxyCodeLine{13257     \textcolor{comment}{//      M+ = f * 2\string^e}}
\DoxyCodeLine{13258     \textcolor{comment}{//         = ((f div 2\string^-\/e) * 2\string^-\/e + (f mod 2\string^-\/e)) * 2\string^e}}
\DoxyCodeLine{13259     \textcolor{comment}{//         = ((p1        ) * 2\string^-\/e + (p2        )) * 2\string^e}}
\DoxyCodeLine{13260     \textcolor{comment}{//         = p1 + p2 * 2\string^e}}
\DoxyCodeLine{13261 }
\DoxyCodeLine{13262     \textcolor{keyword}{const} \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} one(std::uint64\_t\{1\} << -\/M\_plus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_ae22e170815983961447c429f324c944d}{e}}, M\_plus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_ae22e170815983961447c429f324c944d}{e}});}
\DoxyCodeLine{13263 }
\DoxyCodeLine{13264     \textcolor{keyword}{auto} p1 = \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(M\_plus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_aea90459e340a231ca31d46946803ef51}{f}} >> -\/one.e); \textcolor{comment}{// p1 = f div 2\string^-\/e (Since -\/e >= 32, p1 fits into a 32-\/bit int.)}}
\DoxyCodeLine{13265     std::uint64\_t p2 = M\_plus.\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp_aea90459e340a231ca31d46946803ef51}{f}} \& (one.f -\/ 1);                    \textcolor{comment}{// p2 = f mod 2\string^-\/e}}
\DoxyCodeLine{13266 }
\DoxyCodeLine{13267     \textcolor{comment}{// 1)}}
\DoxyCodeLine{13268     \textcolor{comment}{//}}
\DoxyCodeLine{13269     \textcolor{comment}{// Generate the digits of the integral part p1 = d[n-\/1]...d[1]d[0]}}
\DoxyCodeLine{13270 }
\DoxyCodeLine{13271     assert(p1 > 0);}
\DoxyCodeLine{13272 }
\DoxyCodeLine{13273     std::uint32\_t pow10;}
\DoxyCodeLine{13274     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a36ded358763b5dbcea9867660fbe4e28}{find\_largest\_pow10}}(p1, pow10);}
\DoxyCodeLine{13275 }
\DoxyCodeLine{13276     \textcolor{comment}{//      10\string^(k-\/1) <= p1 < 10\string^k, pow10 = 10\string^(k-\/1)}}
\DoxyCodeLine{13277     \textcolor{comment}{//}}
\DoxyCodeLine{13278     \textcolor{comment}{//      p1 = (p1 div 10\string^(k-\/1)) * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))}}
\DoxyCodeLine{13279     \textcolor{comment}{//         = (d[k-\/1]         ) * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))}}
\DoxyCodeLine{13280     \textcolor{comment}{//}}
\DoxyCodeLine{13281     \textcolor{comment}{//      M+ = p1                                             + p2 * 2\string^e}}
\DoxyCodeLine{13282     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))          + p2 * 2\string^e}}
\DoxyCodeLine{13283     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + ((p1 mod 10\string^(k-\/1)) * 2\string^-\/e + p2) * 2\string^e}}
\DoxyCodeLine{13284     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + (                         rest) * 2\string^e}}
\DoxyCodeLine{13285     \textcolor{comment}{//}}
\DoxyCodeLine{13286     \textcolor{comment}{// Now generate the digits d[n] of p1 from left to right (n = k-\/1,...,0)}}
\DoxyCodeLine{13287     \textcolor{comment}{//}}
\DoxyCodeLine{13288     \textcolor{comment}{//      p1 = d[k-\/1]...d[n] * 10\string^n + d[n-\/1]...d[0]}}
\DoxyCodeLine{13289     \textcolor{comment}{//}}
\DoxyCodeLine{13290     \textcolor{comment}{// but stop as soon as}}
\DoxyCodeLine{13291     \textcolor{comment}{//}}
\DoxyCodeLine{13292     \textcolor{comment}{//      rest * 2\string^e = (d[n-\/1]...d[0] * 2\string^-\/e + p2) * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{13293 }
\DoxyCodeLine{13294     \textcolor{keywordtype}{int} n = k;}
\DoxyCodeLine{13295     \textcolor{keywordflow}{while} (n > 0)}
\DoxyCodeLine{13296     \{}
\DoxyCodeLine{13297         \textcolor{comment}{// Invariants:}}
\DoxyCodeLine{13298         \textcolor{comment}{//      M+ = buffer * 10\string^n + (p1 + p2 * 2\string^e)    (buffer = 0 for n = k)}}
\DoxyCodeLine{13299         \textcolor{comment}{//      pow10 = 10\string^(n-\/1) <= p1 < 10\string^n}}
\DoxyCodeLine{13300         \textcolor{comment}{//}}
\DoxyCodeLine{13301         \textcolor{keyword}{const} std::uint32\_t d = p1 / pow10;  \textcolor{comment}{// d = p1 div 10\string^(n-\/1)}}
\DoxyCodeLine{13302         \textcolor{keyword}{const} std::uint32\_t r = p1 \% pow10;  \textcolor{comment}{// r = p1 mod 10\string^(n-\/1)}}
\DoxyCodeLine{13303         \textcolor{comment}{//}}
\DoxyCodeLine{13304         \textcolor{comment}{//      M+ = buffer * 10\string^n + (d * 10\string^(n-\/1) + r) + p2 * 2\string^e}}
\DoxyCodeLine{13305         \textcolor{comment}{//         = (buffer * 10 + d) * 10\string^(n-\/1) + (r + p2 * 2\string^e)}}
\DoxyCodeLine{13306         \textcolor{comment}{//}}
\DoxyCodeLine{13307         assert(d <= 9);}
\DoxyCodeLine{13308         buffer[length++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + d); \textcolor{comment}{// buffer := buffer * 10 + d}}
\DoxyCodeLine{13309         \textcolor{comment}{//}}
\DoxyCodeLine{13310         \textcolor{comment}{//      M+ = buffer * 10\string^(n-\/1) + (r + p2 * 2\string^e)}}
\DoxyCodeLine{13311         \textcolor{comment}{//}}
\DoxyCodeLine{13312         p1 = r;}
\DoxyCodeLine{13313         n-\/-\/;}
\DoxyCodeLine{13314         \textcolor{comment}{//}}
\DoxyCodeLine{13315         \textcolor{comment}{//      M+ = buffer * 10\string^n + (p1 + p2 * 2\string^e)}}
\DoxyCodeLine{13316         \textcolor{comment}{//      pow10 = 10\string^n}}
\DoxyCodeLine{13317         \textcolor{comment}{//}}
\DoxyCodeLine{13318 }
\DoxyCodeLine{13319         \textcolor{comment}{// Now check if enough digits have been generated.}}
\DoxyCodeLine{13320         \textcolor{comment}{// Compute}}
\DoxyCodeLine{13321         \textcolor{comment}{//}}
\DoxyCodeLine{13322         \textcolor{comment}{//      p1 + p2 * 2\string^e = (p1 * 2\string^-\/e + p2) * 2\string^e = rest * 2\string^e}}
\DoxyCodeLine{13323         \textcolor{comment}{//}}
\DoxyCodeLine{13324         \textcolor{comment}{// Note:}}
\DoxyCodeLine{13325         \textcolor{comment}{// Since rest and delta share the same exponent e, it suffices to}}
\DoxyCodeLine{13326         \textcolor{comment}{// compare the significands.}}
\DoxyCodeLine{13327         \textcolor{keyword}{const} std::uint64\_t rest = (std::uint64\_t\{p1\} << -\/one.e) + p2;}
\DoxyCodeLine{13328         \textcolor{keywordflow}{if} (rest <= delta)}
\DoxyCodeLine{13329         \{}
\DoxyCodeLine{13330             \textcolor{comment}{// V = buffer * 10\string^n, with M-\/ <= V <= M+.}}
\DoxyCodeLine{13331 }
\DoxyCodeLine{13332             decimal\_exponent += n;}
\DoxyCodeLine{13333 }
\DoxyCodeLine{13334             \textcolor{comment}{// We may now just stop. But instead look if the buffer could be}}
\DoxyCodeLine{13335             \textcolor{comment}{// decremented to bring V closer to w.}}
\DoxyCodeLine{13336             \textcolor{comment}{//}}
\DoxyCodeLine{13337             \textcolor{comment}{// pow10 = 10\string^n is now 1 ulp in the decimal representation V.}}
\DoxyCodeLine{13338             \textcolor{comment}{// The rounding procedure works with diyfp's with an implicit}}
\DoxyCodeLine{13339             \textcolor{comment}{// exponent of e.}}
\DoxyCodeLine{13340             \textcolor{comment}{//}}
\DoxyCodeLine{13341             \textcolor{comment}{//      10\string^n = (10\string^n * 2\string^-\/e) * 2\string^e = ulp * 2\string^e}}
\DoxyCodeLine{13342             \textcolor{comment}{//}}
\DoxyCodeLine{13343             \textcolor{keyword}{const} std::uint64\_t ten\_n = std::uint64\_t\{pow10\} << -\/one.e;}
\DoxyCodeLine{13344             \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a5bc841e0bee12fd6489d49cf7bd07bb4}{grisu2\_round}}(buffer, length, dist, delta, rest, ten\_n);}
\DoxyCodeLine{13345 }
\DoxyCodeLine{13346             \textcolor{keywordflow}{return};}
\DoxyCodeLine{13347         \}}
\DoxyCodeLine{13348 }
\DoxyCodeLine{13349         pow10 /= 10;}
\DoxyCodeLine{13350         \textcolor{comment}{//}}
\DoxyCodeLine{13351         \textcolor{comment}{//      pow10 = 10\string^(n-\/1) <= p1 < 10\string^n}}
\DoxyCodeLine{13352         \textcolor{comment}{// Invariants restored.}}
\DoxyCodeLine{13353     \}}
\DoxyCodeLine{13354 }
\DoxyCodeLine{13355     \textcolor{comment}{// 2)}}
\DoxyCodeLine{13356     \textcolor{comment}{//}}
\DoxyCodeLine{13357     \textcolor{comment}{// The digits of the integral part have been generated:}}
\DoxyCodeLine{13358     \textcolor{comment}{//}}
\DoxyCodeLine{13359     \textcolor{comment}{//      M+ = d[k-\/1]...d[1]d[0] + p2 * 2\string^e}}
\DoxyCodeLine{13360     \textcolor{comment}{//         = buffer            + p2 * 2\string^e}}
\DoxyCodeLine{13361     \textcolor{comment}{//}}
\DoxyCodeLine{13362     \textcolor{comment}{// Now generate the digits of the fractional part p2 * 2\string^e.}}
\DoxyCodeLine{13363     \textcolor{comment}{//}}
\DoxyCodeLine{13364     \textcolor{comment}{// Note:}}
\DoxyCodeLine{13365     \textcolor{comment}{// No decimal point is generated: the exponent is adjusted instead.}}
\DoxyCodeLine{13366     \textcolor{comment}{//}}
\DoxyCodeLine{13367     \textcolor{comment}{// p2 actually represents the fraction}}
\DoxyCodeLine{13368     \textcolor{comment}{//}}
\DoxyCodeLine{13369     \textcolor{comment}{//      p2 * 2\string^e}}
\DoxyCodeLine{13370     \textcolor{comment}{//          = p2 / 2\string^-\/e}}
\DoxyCodeLine{13371     \textcolor{comment}{//          = d[-\/1] / 10\string^1 + d[-\/2] / 10\string^2 + ...}}
\DoxyCodeLine{13372     \textcolor{comment}{//}}
\DoxyCodeLine{13373     \textcolor{comment}{// Now generate the digits d[-\/m] of p1 from left to right (m = 1,2,...)}}
\DoxyCodeLine{13374     \textcolor{comment}{//}}
\DoxyCodeLine{13375     \textcolor{comment}{//      p2 * 2\string^e = d[-\/1]d[-\/2]...d[-\/m] * 10\string^-\/m}}
\DoxyCodeLine{13376     \textcolor{comment}{//                      + 10\string^-\/m * (d[-\/m-\/1] / 10\string^1 + d[-\/m-\/2] / 10\string^2 + ...)}}
\DoxyCodeLine{13377     \textcolor{comment}{//}}
\DoxyCodeLine{13378     \textcolor{comment}{// using}}
\DoxyCodeLine{13379     \textcolor{comment}{//}}
\DoxyCodeLine{13380     \textcolor{comment}{//      10\string^m * p2 = ((10\string^m * p2) div 2\string^-\/e) * 2\string^-\/e + ((10\string^m * p2) mod 2\string^-\/e)}}
\DoxyCodeLine{13381     \textcolor{comment}{//                = (                   d) * 2\string^-\/e + (                   r)}}
\DoxyCodeLine{13382     \textcolor{comment}{//}}
\DoxyCodeLine{13383     \textcolor{comment}{// or}}
\DoxyCodeLine{13384     \textcolor{comment}{//      10\string^m * p2 * 2\string^e = d + r * 2\string^e}}
\DoxyCodeLine{13385     \textcolor{comment}{//}}
\DoxyCodeLine{13386     \textcolor{comment}{// i.e.}}
\DoxyCodeLine{13387     \textcolor{comment}{//}}
\DoxyCodeLine{13388     \textcolor{comment}{//      M+ = buffer + p2 * 2\string^e}}
\DoxyCodeLine{13389     \textcolor{comment}{//         = buffer + 10\string^-\/m * (d + r * 2\string^e)}}
\DoxyCodeLine{13390     \textcolor{comment}{//         = (buffer * 10\string^m + d) * 10\string^-\/m + 10\string^-\/m * r * 2\string^e}}
\DoxyCodeLine{13391     \textcolor{comment}{//}}
\DoxyCodeLine{13392     \textcolor{comment}{// and stop as soon as 10\string^-\/m * r * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{13393 }
\DoxyCodeLine{13394     assert(p2 > delta);}
\DoxyCodeLine{13395 }
\DoxyCodeLine{13396     \textcolor{keywordtype}{int} m = 0;}
\DoxyCodeLine{13397     \textcolor{keywordflow}{for} (;;)}
\DoxyCodeLine{13398     \{}
\DoxyCodeLine{13399         \textcolor{comment}{// Invariant:}}
\DoxyCodeLine{13400         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * (d[-\/m-\/1] / 10 + d[-\/m-\/2] / 10\string^2 + ...) * 2\string^e}}
\DoxyCodeLine{13401         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (p2                                 ) * 2\string^e}}
\DoxyCodeLine{13402         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (10 * p2)                   ) * 2\string^e}}
\DoxyCodeLine{13403         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * ((10*p2 div 2\string^-\/e) * 2\string^-\/e + (10*p2 mod 2\string^-\/e)) * 2\string^e}}
\DoxyCodeLine{13404         \textcolor{comment}{//}}
\DoxyCodeLine{13405         assert(p2 <= (std::numeric\_limits<std::uint64\_t>::max)() / 10);}
\DoxyCodeLine{13406         p2 *= 10;}
\DoxyCodeLine{13407         \textcolor{keyword}{const} std::uint64\_t d = p2 >> -\/one.e;     \textcolor{comment}{// d = (10 * p2) div 2\string^-\/e}}
\DoxyCodeLine{13408         \textcolor{keyword}{const} std::uint64\_t r = p2 \& (one.f -\/ 1); \textcolor{comment}{// r = (10 * p2) mod 2\string^-\/e}}
\DoxyCodeLine{13409         \textcolor{comment}{//}}
\DoxyCodeLine{13410         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (d * 2\string^-\/e + r) * 2\string^e}}
\DoxyCodeLine{13411         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (d + r * 2\string^e))}}
\DoxyCodeLine{13412         \textcolor{comment}{//         = (buffer * 10 + d) * 10\string^(-\/m-\/1) + 10\string^(-\/m-\/1) * r * 2\string^e}}
\DoxyCodeLine{13413         \textcolor{comment}{//}}
\DoxyCodeLine{13414         assert(d <= 9);}
\DoxyCodeLine{13415         buffer[length++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + d); \textcolor{comment}{// buffer := buffer * 10 + d}}
\DoxyCodeLine{13416         \textcolor{comment}{//}}
\DoxyCodeLine{13417         \textcolor{comment}{//      M+ = buffer * 10\string^(-\/m-\/1) + 10\string^(-\/m-\/1) * r * 2\string^e}}
\DoxyCodeLine{13418         \textcolor{comment}{//}}
\DoxyCodeLine{13419         p2 = r;}
\DoxyCodeLine{13420         m++;}
\DoxyCodeLine{13421         \textcolor{comment}{//}}
\DoxyCodeLine{13422         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * p2 * 2\string^e}}
\DoxyCodeLine{13423         \textcolor{comment}{// Invariant restored.}}
\DoxyCodeLine{13424 }
\DoxyCodeLine{13425         \textcolor{comment}{// Check if enough digits have been generated.}}
\DoxyCodeLine{13426         \textcolor{comment}{//}}
\DoxyCodeLine{13427         \textcolor{comment}{//      10\string^-\/m * p2 * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{13428         \textcolor{comment}{//              p2 * 2\string^e <= 10\string^m * delta * 2\string^e}}
\DoxyCodeLine{13429         \textcolor{comment}{//                    p2 <= 10\string^m * delta}}
\DoxyCodeLine{13430         delta *= 10;}
\DoxyCodeLine{13431         dist  *= 10;}
\DoxyCodeLine{13432         \textcolor{keywordflow}{if} (p2 <= delta)}
\DoxyCodeLine{13433         \{}
\DoxyCodeLine{13434             \textcolor{keywordflow}{break};}
\DoxyCodeLine{13435         \}}
\DoxyCodeLine{13436     \}}
\DoxyCodeLine{13437 }
\DoxyCodeLine{13438     \textcolor{comment}{// V = buffer * 10\string^-\/m, with M-\/ <= V <= M+.}}
\DoxyCodeLine{13439 }
\DoxyCodeLine{13440     decimal\_exponent -\/= m;}
\DoxyCodeLine{13441 }
\DoxyCodeLine{13442     \textcolor{comment}{// 1 ulp in the decimal representation is now 10\string^-\/m.}}
\DoxyCodeLine{13443     \textcolor{comment}{// Since delta and dist are now scaled by 10\string^m, we need to do the}}
\DoxyCodeLine{13444     \textcolor{comment}{// same with ulp in order to keep the units in sync.}}
\DoxyCodeLine{13445     \textcolor{comment}{//}}
\DoxyCodeLine{13446     \textcolor{comment}{//      10\string^m * 10\string^-\/m = 1 = 2\string^-\/e * 2\string^e = ten\_m * 2\string^e}}
\DoxyCodeLine{13447     \textcolor{comment}{//}}
\DoxyCodeLine{13448     \textcolor{keyword}{const} std::uint64\_t ten\_m = one.f;}
\DoxyCodeLine{13449     \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a5bc841e0bee12fd6489d49cf7bd07bb4}{grisu2\_round}}(buffer, length, dist, delta, p2, ten\_m);}
\DoxyCodeLine{13450 }
\DoxyCodeLine{13451     \textcolor{comment}{// By construction this algorithm generates the shortest possible decimal}}
\DoxyCodeLine{13452     \textcolor{comment}{// number (Loitsch, Theorem 6.2) which rounds back to w.}}
\DoxyCodeLine{13453     \textcolor{comment}{// For an input number of precision p, at least}}
\DoxyCodeLine{13454     \textcolor{comment}{//}}
\DoxyCodeLine{13455     \textcolor{comment}{//      N = 1 + ceil(p * log\_10(2))}}
\DoxyCodeLine{13456     \textcolor{comment}{//}}
\DoxyCodeLine{13457     \textcolor{comment}{// decimal digits are sufficient to identify all binary floating-\/point}}
\DoxyCodeLine{13458     \textcolor{comment}{// numbers (Matula, "{}In-\/and-\/Out conversions"{}).}}
\DoxyCodeLine{13459     \textcolor{comment}{// This implies that the algorithm does not produce more than N decimal}}
\DoxyCodeLine{13460     \textcolor{comment}{// digits.}}
\DoxyCodeLine{13461     \textcolor{comment}{//}}
\DoxyCodeLine{13462     \textcolor{comment}{//      N = 17 for p = 53 (IEEE double precision)}}
\DoxyCodeLine{13463     \textcolor{comment}{//      N = 9  for p = 24 (IEEE single precision)}}
\DoxyCodeLine{13464 \}}

\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_a9b899c72b0e1e3dd46d75c2b4e6bcdfb_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_a9b899c72b0e1e3dd46d75c2b4e6bcdfb_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a5bc841e0bee12fd6489d49cf7bd07bb4}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a5bc841e0bee12fd6489d49cf7bd07bb4}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!grisu2\_round@{grisu2\_round}}
\index{grisu2\_round@{grisu2\_round}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{grisu2\_round()}{grisu2\_round()}}
{\footnotesize\ttfamily void nlohmann\+::detail\+::dtoa\+\_\+impl\+::grisu2\+\_\+round (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf,  }\item[{int}]{len,  }\item[{std\+::uint64\+\_\+t}]{dist,  }\item[{std\+::uint64\+\_\+t}]{delta,  }\item[{std\+::uint64\+\_\+t}]{rest,  }\item[{std\+::uint64\+\_\+t}]{ten\+\_\+k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 13190 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13192 \{}
\DoxyCodeLine{13193     assert(len >= 1);}
\DoxyCodeLine{13194     assert(dist <= delta);}
\DoxyCodeLine{13195     assert(rest <= delta);}
\DoxyCodeLine{13196     assert(ten\_k > 0);}
\DoxyCodeLine{13197 }
\DoxyCodeLine{13198     \textcolor{comment}{//               <-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ delta -\/-\/-\/-\/>}}
\DoxyCodeLine{13199     \textcolor{comment}{//                                  <-\/-\/-\/-\/ dist -\/-\/-\/-\/-\/-\/-\/-\/-\/>}}
\DoxyCodeLine{13200     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{13201     \textcolor{comment}{//               M-\/                 w                   M+}}
\DoxyCodeLine{13202     \textcolor{comment}{//}}
\DoxyCodeLine{13203     \textcolor{comment}{//                                  ten\_k}}
\DoxyCodeLine{13204     \textcolor{comment}{//                                <-\/-\/-\/-\/-\/-\/>}}
\DoxyCodeLine{13205     \textcolor{comment}{//                                       <-\/-\/-\/-\/ rest -\/-\/-\/-\/>}}
\DoxyCodeLine{13206     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{13207     \textcolor{comment}{//                                  w    V}}
\DoxyCodeLine{13208     \textcolor{comment}{//                                       = buf * 10\string^k}}
\DoxyCodeLine{13209     \textcolor{comment}{//}}
\DoxyCodeLine{13210     \textcolor{comment}{// ten\_k represents a unit-\/in-\/the-\/last-\/place in the decimal representation}}
\DoxyCodeLine{13211     \textcolor{comment}{// stored in buf.}}
\DoxyCodeLine{13212     \textcolor{comment}{// Decrement buf by ten\_k while this takes buf closer to w.}}
\DoxyCodeLine{13213 }
\DoxyCodeLine{13214     \textcolor{comment}{// The tests are written in this order to avoid overflow in unsigned}}
\DoxyCodeLine{13215     \textcolor{comment}{// integer arithmetic.}}
\DoxyCodeLine{13216 }
\DoxyCodeLine{13217     \textcolor{keywordflow}{while} (rest < dist}
\DoxyCodeLine{13218             and delta -\/ rest >= ten\_k}
\DoxyCodeLine{13219             and (rest + ten\_k < dist or dist -\/ rest > rest + ten\_k -\/ dist))}
\DoxyCodeLine{13220     \{}
\DoxyCodeLine{13221         assert(buf[len -\/ 1] != \textcolor{charliteral}{'0'});}
\DoxyCodeLine{13222         buf[len -\/ 1]-\/-\/;}
\DoxyCodeLine{13223         rest += ten\_k;}
\DoxyCodeLine{13224     \}}
\DoxyCodeLine{13225 \}}

\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacenlohmann_1_1detail_1_1dtoa__impl_a5bc841e0bee12fd6489d49cf7bd07bb4_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a1c5d30eb51e5e994a3f48bde104d2ce8}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a1c5d30eb51e5e994a3f48bde104d2ce8}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!reinterpret\_bits@{reinterpret\_bits}}
\index{reinterpret\_bits@{reinterpret\_bits}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{reinterpret\_bits()}{reinterpret\_bits()}}
{\footnotesize\ttfamily template$<$typename Target , typename Source $>$ \\
Target nlohmann\+::detail\+::dtoa\+\_\+impl\+::reinterpret\+\_\+bits (\begin{DoxyParamCaption}\item[{const Source}]{source }\end{DoxyParamCaption})}



Definition at line 12690 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{12691 \{}
\DoxyCodeLine{12692     static\_assert(\textcolor{keyword}{sizeof}(Target) == \textcolor{keyword}{sizeof}(Source), \textcolor{stringliteral}{"{}size mismatch"{}});}
\DoxyCodeLine{12693 }
\DoxyCodeLine{12694     Target target;}
\DoxyCodeLine{12695     std::memcpy(\&target, \&source, \textcolor{keyword}{sizeof}(Source));}
\DoxyCodeLine{12696     \textcolor{keywordflow}{return} target;}
\DoxyCodeLine{12697 \}}

\end{DoxyCode}


\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_ac1ea1316de0b4a219f707c76b1db1966}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_ac1ea1316de0b4a219f707c76b1db1966}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!kAlpha@{kAlpha}}
\index{kAlpha@{kAlpha}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{kAlpha}{kAlpha}}
{\footnotesize\ttfamily constexpr int nlohmann\+::detail\+::dtoa\+\_\+impl\+::k\+Alpha = -\/60\hspace{0.3cm}{\ttfamily [constexpr]}}



Definition at line 12953 of file json.\+hpp.

\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a4a750fcc38da1ce68b7e25ab3a230e20}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a4a750fcc38da1ce68b7e25ab3a230e20}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!kGamma@{kGamma}}
\index{kGamma@{kGamma}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{kGamma}{kGamma}}
{\footnotesize\ttfamily constexpr int nlohmann\+::detail\+::dtoa\+\_\+impl\+::k\+Gamma = -\/32\hspace{0.3cm}{\ttfamily [constexpr]}}



Definition at line 12954 of file json.\+hpp.

